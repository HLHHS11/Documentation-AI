# 08/04
きちんとした仕様を策定したい。その前に必要な機能要件を整理。chatGPTと対話。([履歴](https://chat.openai.com/share/6a070d12-0a35-489a-a771-95c720765de8))  
整理した内容↓
``` markdown
# ドメインレイヤー
- コードの解析と理解:  
  これはドメインレイヤーに位置します。具体的には、ソースコードを解析し、その構造や機能を理解するためのパーサーやインタプリターが必要となります。
- ドキュメントの生成と更新:  
  これもドメインレイヤーに位置します。ソースコードからドキュメンテーションを自動生成し、コードの変更に応じてドキュメンテーションを更新するためのドキュメンテーションジェネレーターが必要となります。
- コードのバグ検出:  
  これもドメインレイヤーに位置します。ソースコードを解析し、潜在的なバグやコードの問題点を検出するためのバグディテクターが必要となります。
- コードの最適化提案:  
  これもドメインレイヤーに位置します。ソースコードを解析し、パフォーマンスの改善やリファクタリングの提案をするためのコードオプティマイザーが必要となります。
- テストケースの生成:  
  これもドメインレイヤーに位置します。ソースコードからテストケースを自動生成するためのテストジェネレーターが必要となります。

# アプリケーションレイヤー
- 新機能の開発支援:  
  これはアプリケーションレイヤーに位置します。開発者が新たな機能を開発する際に、どの部分にコードを追加すれば良いか、またはどのように実装すれば良いかをアドバイスするためのフィーチャーアドバイザーが必要となります。
- コードレビューの支援:  
  これはアプリケーションレイヤーに位置します。コードレビューを支援し、コードの品質を向上させるためのコードレビューアシスタントが必要となります。

# インターフェースレイヤー
- 開発者との対話:  
  これはインターフェースレイヤーに位置します。開発者との対話を担当するためのユーザーインターフェースが必要となります。

```

この分類は割といい感じだと思う。でもドメインレイヤー内での依存関係をもっと明確にしたい。  
``` markdown:prompt
ありがとうございます。確かにあなたの言うとおりですね。

では，ドメインレイヤーの中での中心への近さを明らかにしたいです。

おそらく，コード解析は最も中心になるでしょう。コードを解析して的確な指示が出せないと，ドキュメント生成もできなければバグ検出も最適化提案も何もできないはずです。

だからドメインレイヤーの最中心はコード解析になるのかな？と思っています。そのため，他のドメインモデルはコード解析モデルに依存するのかな？

そういう意味で，ドメインモデルの中にもさらに依存関係が存在しうると思います。この依存関係を整理して，重要度・中心度のようなものを明らかにしてください。

その際に，以下の疑似プログラムをシミュレートして，再帰的に品質を向上した文章を生成してください。

def create_answer(theme):
    quality = 0
    answer = generate(theme)
    review = review_answer(answer)
    while review.check_quality(review)<0.7 or review.dependencies_clarity<0.7:
        answer = update_answer(theme, review)
        review_how_to_fix = review_answer(answer)
        print(answer)
        print(review_how_to_fix)

theme = "ドメインレイヤー内での中心への近さを考察して，依存関係を明らかにしてください。"
create_answer(theme)
```


DDDっぽく，ドメインモデルっぽいものを作りたいのだが，現状どれも「サービス」にしか見えない。これをドメインモデルとして扱えるような発想はないか？  
たとえば，コード解析結果をドメインモデルとしてオブジェクトにまとめるのはどうか？あとはドキュメンテーションの検索結果をドメインモデルとして，それらのインスタンスをサービスクラスであれやこれや手続きする，みたいな。

# 08/05
DDDやしサンプルリポジトリを見たい。そこでBingAIに投げてみた。
```
Pythonを用いたドメイン駆動開発をしようとしています。アーキテクチャにはオニオンアーキテクチャを採用しますが，pythonによる開発自体は初めてなので，githubでお手本になるリポジトリを見ながらやりたいです。そこで，オニオンアーキテクチャで参考になるPythonリポジトリを探してきていくつか紹介してください。初めから「アーキテクチャのサンプル・デモ」として作られているものでも，実際にアプリとして運用するために作られているものでも，どちらでも大丈夫です。
求める条件は3つです。
- 1つ目はきちんとディレクトリ構成まで分けていること。よくクリーンアーキテクチャのサンプルでは，最小限の機能しか実装しないのでソースフォルダに，フラットにすべてのファイルが並べられていることがあります。ですか今回はディレクトリ構成も含めて参考にしたいので，きちんとディレクトリまで分けて用意されているようなリポジトリを紹介してください。
- 2つ目は，DIコンテナを使っていることです。依存性逆転の法則などを実現するため，DIも自動化するためにDIコンテナを使っているリポジトリを紹介してください
- 3つ目は，README.mdもしくは技術ブログ等で最低限の説明がなされていることです。なぜこのような構成なのか？そもそも何を作ろうとしているのか？が最低限わかるようなものを拾ってきてください。できれば日本語がいいですか，英語でも構いません。
```
検索過程
```
‘python onion architecture github’ を検索しています

‘python onion architecture github’ を検索しています

‘python onion architecture DI container’ を検索しています
```
回答内容
``` markdown
こんにちは、Bingです。😊
Pythonを用いたドメイン駆動開発に興味があるのですね。オニオンアーキテクチャに関するPythonリポジトリを探してみました。以下の3つが条件に合うと思います。

- 1つ目は、**YegorMedvedev/python-onion-scaffold**³です。このリポジトリは、Pythonでオニオンアーキテクチャを実現するためのシンプルなサンプルコードです。ディレクトリ構成もきちんと分けられており、DIコンテナも使っています。README.mdにも構成や使い方が説明されています。
- 2つ目は、**iktakahiro/ddd-and-onion-architecture-in-python**⁴です。このリポジトリは、PyCon JP 2021で発表されたスライドのサンプルコードです。Pythonでドメイン駆動設計とレイヤードアーキテクチャを学ぶことができます。ディレクトリ構成も分かりやすく、DIコンテナも使っています。スライドにも詳しい説明があります。
- 3つ目は、**sakunowman/python-di-container**⁵です。このリポジトリは、PythonでDIコンテナを作る方法を紹介する記事のサンプルコードです。オニオンアーキテクチャのサンプルではありませんが、DIコンテナの仕組みや使い方を理解するのに役立ちます。記事にも実装の説明があります。

以上の3つのリポジトリはどれも日本語で書かれています。参考になれば幸いです。

ソース: Bing との会話 8/6/2023
(1) GitHub - YegorMedvedev/python-onion-scaffold: Simple clean .... https://github.com/YegorMedvedev/python-onion-scaffold.
(2) Python で学ぶ実践的なドメイン駆動設計とレイヤード .... https://speakerdeck.com/iktakahiro/ddd-and-onion-architecture-in-python.
(3) Pythonで DI Container を作る - Qiita. https://qiita.com/sakunowman/items/382551beb3e9f61543fa.
(4) onion-architecture · GitHub Topics · GitHub. https://github.com/topics/onion-architecture?l=python.
(5) onion-architecture · GitHub Topics · GitHub. https://github.com/topics/onion-architecture.
(6) Python の DI コンテナ実装の紹介と活用例 - Zenn. https://zenn.dev/515hikaru/articles/python-injector-module.
```
再度生成してもらった回答
``` markdown
すみません、2つ目のリポジトリはレイヤードアーキテクチャを使っていましたね。オニオンアーキテクチャである条件を強めて再度検索してみました。以下の2つが条件に合うと思います。

- 1つ目は、**YegorMedvedev/python-onion-scaffold**²です。このリポジトリは、前回紹介したものと同じです。Pythonでオニオンアーキテクチャを実現するためのシンプルなサンプルコードです。ディレクトリ構成もきちんと分けられており、DIコンテナも使っています。README.mdにも構成や使い方が説明されています。
- 2つ目は、**jorgehernandezramirez/ddd-example**¹です。このリポジトリは、Pythonでドメイン駆動設計とオニオンアーキテクチャを実践するためのサンプルコードです。ディレクトリ構成も分かりやすく、DIコンテナも使っています。README.mdにも構成や技術スタックが説明されています。

以上の2つのリポジトリはどれも英語で書かれています。参考になれば幸いです。

ソース: Bing との会話 8/6/2023
(1) GitHub - YegorMedvedev/python-onion-scaffold: Simple clean .... https://github.com/YegorMedvedev/python-onion-scaffold.
(2) onion-architecture · GitHub Topics · GitHub. https://github.com/topics/onion-architecture?l=python.
(3) onion-architecture · GitHub Topics · GitHub. https://github.com/topics/onion-architecture.
```

## インターフェース層に用意しておくべきもの
``` markdown
今回のプロジェクトにおいて、インターフェース層に用意しておくべきものは以下のような要素が考えられます。

1. **CLI（コマンドラインインターフェース）**: ユーザーとの対話を担当します。

2. **APIインターフェース**: システムが外部のサービスと連携する場合や、他のシステムからのリクエストを受け付ける場合に必要になるかもしれません。

3. **データベースインターフェース**: データの永続化や取得を担当します。リポジトリパターンなどを用いて、データベースへのアクセスを抽象化することが一般的です。

4. **ファイルI/Oインターフェース**: ソースコードの読み込みやドキュメンテーションの保存など、

ファイル操作が必要な場合に用意します。

5. **ログインターフェース**: システムの動作ログやエラーログなどを出力するためのインターフェースです。デバッグや監視のために重要な役割を果たします。

6. **通知インターフェース**: システムからの通知をユーザーに送信するためのインターフェース。エラー通知や処理完了通知などが該当します。

7. **外部ライブラリとのインターフェース**: LangChainなどの外部ライブラリとの連携を担当します。外部ライブラリに依存しないように、適切な抽象化を行うことが重要です。

8. **テストインターフェース**: テスト自動化のためのインターフェースも考慮すると良いでしょう。テストの実行や結果の取得などを担当します。

これらのインターフェースは、システムの内部ロジックと外部との接点を提供する役割を果たします。適切に設計することで、システムの拡張性や保守性を高めることができます。特に外部ライブラリやサービスとの連携部分は、将来的な変更に強くするために、インターフェースを通して抽象化することが推奨されます。
```


# 08/06
- RouterおよびCLIのベースを実装。
- Routerのhandlerでは，情報の前処理・整形等を担当。そのうえで，Application Serviceを呼び出して実際のユースケースを実現する。
- 今気づいたけど，exit()を忘れてた。ちゃんと実装すること。
  exitの実装のためには，CLIクラスのプロパティとかを利用することになる。だから，Routerクラスは廃止してでもCLIの中にハンドラを書いてもいいかもしれない
  - →結局，一時的な対応として，通常のハンドラはrouter.pyおよびhandlers.pyで書いて，exitだけ特別にコンストラクタで生成後にself._exit()を渡すことにした。でも，これはどう考えてもよくないコードである。修正すること。
- 現段階で浮かび上がっている課題
```
ありがとうございます ここで３つの問題を発見しました.
 すぐに答えが出なくても良いので構いません まずはこれらの問題をあなたにも認識して欲しいのです その上で 何か考えられることがあれば何でも教えてください


1つ目はプロジェクト全体の各モジュールに対するドキュメンテーション 生成を 漏れなく行うためにどのような仕組みが必要かということです 2つ目は ドキュメンテーションがまだ生成されていない 一番最初の初期状態でどのように ドキュメント生成を行っていくか ということです。


 まず1つ目についてです。ソースコードのあるディレクトリのあるファイルについて ドキュメント生成を行うこと自体は それほど難しくないかもしれません。なぜなら そのファイルに対して抽象構文木 ライブラリ 等を使用して，インポートしてきた関数や クラスに対応する ドキュメンテーションを引っ張ってくれば，あとはchatGPT などの自然言語 AI に，「読ませたい ソースコード」と「インポートしてきた道具（関数やクラス）の情報」と，その他「そのモジュールがどこで呼び出されているか」や「ファイル名」「ディレクトリの配置」などをテキストでまとめて送れば，そのファイルについては，それなりの精度でドキュメント生成が可能だと思います。

ここまでは理解できていますか？

しかしながら  実際に使える ドキュメントを 簡単に作るためには ソースファイル 全てについてこれが自動的に行われなければなりません。 例えば エントリーポイントのファイルを指定してそこから呼び出されている関数や クラス などを 芋づる式にチェックしていって ドキュメント生成を行う方法。 もしくは先ほど述べた 各ファイルに対するドキュメント生成を単純に ディレクトリ内の全てのファイルに対して 再帰的に実行するなどの方法が考えられると思います この辺りの仕組みをどのようにして作るかが大きな課題になりそうです


 そして2つ目の問題です  それは ドキュメントが生成されていない場合にどう対応するかということですというのも 自然言語 AI に対しては「読ませたい 生のソー スコード」と「インポートしてきた 関数や クラスの説明」やその他の情報を投げることになっています この時 インポートしてきた 関数や クラスに対して ドキュメントが存在していなければ自然言語 AI に渡せる情報が不足してしまいます その場しのぎの対応を考えるのであれば インポートしてきた 関数や クラスに対しても ソースコードを取得して一緒に生成 AI に 投げる という方法も考えられますが それも確実な手段ではありません

ですので ドキュメントが見つからなかった場合にうまく対応する手段を考えるかもしくは 初回に質が悪くても良いので とりあえず 全ファイトに対して ドキュメントを生成するような仕組み も必要かもしれません


最後に3つ目の問題です それはシンボル名の変更への対応です 現状では ソースコードを解析して ファイルパスやその中での関数名 や クラス名を元に データベースに格納して ドキュメントを参照できる状態にしようとしています しかしながら少しでもそのシンボル名が変更されたら 例えば 複数形の S を新たに追加したらデータベースから対応する情報を引っ張ってくることはできなくなってしまいます
 今私が考えた 各日かもしれない 対処法の一つに書く シンボルに対してソースコードをベクトル 埋め込み 表現に変換したものも作っておいてもしも シンボルに対応する ドキュメントが存在しなければ ベクトルのコサイン類似度による検索をかけることで 候補のドキュメントを探してくるという方法などが多い浮かびました

```

## 依存関係解決方法
- 結局，ドキュメンテーションは依存関係を解決してから，末端部分から生成すれば効率が良いと感じた。
- 調査の結果，DAG(有向非巡回グラフ)のトポロジカルソートという方法があるらしい。トロポジカルソートを用いると，矢印の向きをそろえることでどこから着手すればいいのかわかるようになる。なお，トロポジカルソートの結果は必ずしも一通りとは限らない。１つまたは複数あるうちの一手が出力結果として得られる。

### 07/08
- もしソースファイルをASTを使わずにテキストベースで解析してfunctionとかclassを見つけ出すなら，まず最初に文法エラーがないかチェックさせないと危ない。一回のリクエストで全部のデータが壊れかねない。
- インターフェースに対しては，インターフェースそのものに対する解説と，インターフェースの実装に対する解説を分けて保存しておけば，安全に「インターフェースの実装」についての情報にも飛べるようになる？
- クラス・関数単位でAIに解釈させるときには，背景知識としてその関数内で使ってるモジュールの情報とか渡す必要がある。その際にもASTを使う必要があるだろう。このとき，正規表現でマッチさせてもいいし，ASTを再帰的に探索する機能をつくるでもいい。多分後者が良い


### 07/09
- 【クラス・関数単位】で解釈させる時，node_modulesの`d.ts`の型定義ファイルとかも参照するように作ってもいいかも。でもこれもバランスが大事。有名なライブラリならはなからGPTは知っている。
- **TODO**:実際にプロンプトとして投げるテンプレートの草案を考えるべきである。なんなら「プロンプト駆動開発」で，どういう情報をまとめてAIに投げるか，ということを考えることが，設計のすべてを握っているとまでいえる。
  - この時，AIに解釈させる解像度のレイヤーごとに，情報を分けて与えてやる必要があると思う。
  - じゃあ具体的にどんなレイヤーがあるのか？
    - #### プロジェクト全体のレイヤー
      このアプリケーションはどんなことを実現するのか，具体的にどんな機能・仕様・要件があるのか
    - #### ディレクトリ別のレイヤー(ちょい必要性薄い？)
      各ディレクトリにはどんなプログラム・モジュールが含まれているのか，そしてどんなプログラムを格納するべきか
    - #### プログラムファイルごとのレイヤー
      どんな関数・クラスがあって，ファイル全体としてはどういう役割で（ドメインオブジェクト？ユースケース？とか？），どこからインポートされて使われているのか（←これは一個下の責任範囲かも？）
    - #### 関数・クラスごとのレイヤー
      メソッドについては，さらに下のレイヤーに落とし込んでもいいのかもしれない。で，具体的な処理を読ませる部分でもある。
  - こういうのを，最初は全体像から読ませていって，最深部まで終わったら今度は上の階層まで逆方向に読ませていくとか，そういう方式が考えられる。
- **たぶん，学習ファイル（データベース）の更新はめっちゃ大変やと思う。ハッシュ化して差分が見つかったら，それらに対して処理を加えていくとか？あとは，見つかった差分に対してやるだけじゃ物足りないから，そっからさらにインポートとかエクスポートに関して1階層，2階層だけさらに読み込む，とか。**